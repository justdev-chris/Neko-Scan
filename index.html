<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NEKOSCAN PRO</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/body-pix@2.0.0/dist/body-pix.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0a;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 500px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ffff;
            margin-bottom: 20px;
            font-size: 24px;
            text-shadow: 0 0 10px #00ffff;
        }
        
        .status {
            text-align: center;
            margin: 15px 0;
            color: #ffff00;
            font-size: 14px;
            min-height: 20px;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            background: #111;
            border: 2px solid #333;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        #cameraFeed {
            width: 100%;
            display: block;
        }
        
        #scanOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin: 20px 0;
        }
        
        button {
            background: #222;
            color: #00ff00;
            border: 1px solid #00ff00;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 15px #00ff00;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #captureBtn {
            background: #004400;
            border-color: #00ff00;
        }
        
        #processingCanvas, #outputCanvas {
            display: none;
        }
        
        .result-container {
            display: none;
            margin-top: 20px;
        }
        
        #resultImage {
            width: 100%;
            border: 2px solid #333;
            border-radius: 8px;
        }
        
        .loading {
            border: 3px solid #333;
            border-top: 3px solid #00ff00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .scan-animation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, transparent, #00ff00, transparent);
            animation: scan 2s linear infinite;
            box-shadow: 0 0 10px #00ff00;
        }
        
        @keyframes scan {
            0% { top: 0; }
            100% { top: 100%; }
        }
        
        .corner {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff00;
        }
        
        .corner-tl { top: 10px; left: 10px; border-right: none; border-bottom: none; }
        .corner-tr { top: 10px; right: 10px; border-left: none; border-bottom: none; }
        .corner-bl { bottom: 10px; left: 10px; border-right: none; border-top: none; }
        .corner-br { bottom: 10px; right: 10px; border-left: none; border-top: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>NEKOSCAN PRO</h1>
        <div class="status" id="status">INITIALIZING ADVANCED SCANNER...</div>
        
        <div class="camera-container">
            <video id="cameraFeed" autoplay playsinline></video>
            <canvas id="scanOverlay"></canvas>
            <div class="scan-animation"></div>
            <div class="corner corner-tl"></div>
            <div class="corner corner-tr"></div>
            <div class="corner corner-bl"></div>
            <div class="corner corner-br"></div>
        </div>
        
        <div class="controls">
            <button id="toggleCamera">SWITCH CAMERA</button>
            <button id="flashToggle">FLASH: OFF</button>
            <button id="captureBtn">CAPTURE DOCUMENT</button>
            <button id="autoScanBtn" style="background: #004400;">AUTO-SCAN: ON</button>
        </div>
        
        <canvas id="processingCanvas"></canvas>
        <canvas id="outputCanvas"></canvas>
        
        <div class="result-container" id="resultContainer">
            <img id="resultImage" alt="Scanned Document">
            <div class="controls">
                <button id="retakeBtn">SCAN AGAIN</button>
                <button id="savePdfBtn">SAVE AS PDF</button>
                <button id="enhanceBtn">ENHANCE QUALITY</button>
                <button id="shareBtn">SHARE</button>
            </div>
        </div>
        
        <div class="loading" id="loading" style="display: none;"></div>
    </div>

    <script>
        const video = document.getElementById('cameraFeed');
        const processingCanvas = document.getElementById('processingCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const scanOverlay = document.getElementById('scanOverlay');
        const resultImage = document.getElementById('resultImage');
        const status = document.getElementById('status');
        const loading = document.getElementById('loading');
        const resultContainer = document.getElementById('resultContainer');

        const ctx = processingCanvas.getContext('2d');
        const outputCtx = outputCanvas.getContext('2d');
        const overlayCtx = scanOverlay.getContext('2d');

        let currentStream = null;
        let isAutoScan = true;
        let isFrontCamera = false;
        let flashOn = false;
        let scanInterval = null;

        // Initialize advanced scanner
        async function initializeScanner() {
            status.textContent = 'LOADING AI SCANNER...';
            loading.style.display = 'block';
            
            try {
                await startCamera();
                setupScanOverlay();
                startRealTimeDetection();
                status.textContent = 'SCANNER READY - POINT AT DOCUMENT';
                loading.style.display = 'none';
            } catch (error) {
                status.textContent = 'ERROR: ' + error.message;
                loading.style.display = 'none';
            }
        }

        // Start camera with best available settings
        async function startCamera() {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }

            const constraints = {
                video: {
                    facingMode: isFrontCamera ? 'user' : 'environment',
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    frameRate: { ideal: 30 }
                },
                audio: false
            };

            try {
                currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = currentStream;
                
                return new Promise((resolve) => {
                    video.onloadedmetadata = () => {
                        setupCanvases();
                        resolve();
                    };
                });
            } catch (err) {
                throw new Error('Camera access denied. Please enable camera permissions.');
            }
        }

        function setupCanvases() {
            const width = video.videoWidth;
            const height = video.videoHeight;
            
            processingCanvas.width = width;
            processingCanvas.height = height;
            outputCanvas.width = width;
            outputCanvas.height = height;
            scanOverlay.width = width;
            scanOverlay.height = height;
        }

        function setupScanOverlay() {
            overlayCtx.strokeStyle = '#00ff00';
            overlayCtx.lineWidth = 3;
            overlayCtx.shadowBlur = 10;
            overlayCtx.shadowColor = '#00ff00';
        }

        // Real-time document detection using advanced computer vision
        function startRealTimeDetection() {
            function detectDocument() {
                if (video.paused || video.ended) return;

                ctx.drawImage(video, 0, 0);
                const imageData = ctx.getImageData(0, 0, processingCanvas.width, processingCanvas.height);
                
                // Advanced edge detection
                const edges = detectEdgesAdvanced(imageData);
                const documentContour = findDocumentContour(edges);
                
                drawDetectionOverlay(documentContour);
                
                // Auto-capture if enabled and document is detected
                if (isAutoScan && documentContour && isDocumentWellPositioned(documentContour)) {
                    performScan(documentContour);
                }
                
                requestAnimationFrame(detectDocument);
            }
            
            detectDocument();
        }

        function detectEdgesAdvanced(imageData) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            const edges = new Uint8ClampedArray(width * height * 4);
            
            // Advanced Sobel edge detection
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    let gx = 0, gy = 0;
                    
                    // Sobel X and Y kernels
                    for (let ky = -1; ky <= 1; ky++) {
                        for (let kx = -1; kx <= 1; kx++) {
                            const idx = ((y + ky) * width + (x + kx)) * 4;
                            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
                            
                            // Sobel X kernel weight
                            if (kx === -1) gx += brightness * -1;
                            else if (kx === 1) gx += brightness * 1;
                            if (ky === -1) gx += brightness * -2;
                            else if (ky === 1) gx += brightness * 2;
                            
                            // Sobel Y kernel weight
                            if (ky === -1) gy += brightness * -1;
                            else if (ky === 1) gy += brightness * 1;
                            if (kx === -1) gy += brightness * -2;
                            else if (kx === 1) gy += brightness * 2;
                        }
                    }
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    const edgeValue = magnitude > 100 ? 255 : 0;
                    
                    const edgeIdx = (y * width + x) * 4;
                    edges[edgeIdx] = edgeValue;     // R
                    edges[edgeIdx + 1] = edgeValue; // G
                    edges[edgeIdx + 2] = edgeValue; // B
                    edges[edgeIdx + 3] = 255;       // A
                }
            }
            
            return new ImageData(edges, width, height);
        }

        function findDocumentContour(edges) {
            const width = edges.width;
            const height = edges.height;
            const data = edges.data;
            
            // Find potential document corners (simplified for demo)
            // In production, this would use Hough Transform or ML
            const corners = [];
            const sensitivity = 50;
            
            // Sample corner detection (simplified)
            for (let y = sensitivity; y < height - sensitivity; y += 20) {
                for (let x = sensitivity; x < width - sensitivity; x += 20) {
                    const idx = (y * width + x) * 4;
                    if (data[idx] > 200) { // Strong edge
                        corners.push({x, y});
                    }
                }
            }
            
            // Find the largest quadrilateral
            if (corners.length >= 4) {
                return findLargestQuadrilateral(corners);
            }
            
            return null;
        }

        function findLargestQuadrilateral(corners) {
            // Simplified - find corners near each screen edge
            const width = processingCanvas.width;
            const height = processingCanvas.height;
            const margin = 50;
            
            const tl = corners.filter(c => c.x < width/2 && c.y < height/2)
                            .sort((a,b) => (a.x + a.y) - (b.x + b.y))[0];
            const tr = corners.filter(c => c.x > width/2 && c.y < height/2)
                            .sort((a,b) => (a.x - a.y) - (b.x - b.y))[0];
            const bl = corners.filter(c => c.x < width/2 && c.y > height/2)
                            .sort((a,b) => (a.x - a.y) - (b.x - b.y))[0];
            const br = corners.filter(c => c.x > width/2 && c.y > height/2)
                            .sort((a,b) => (a.x + a.y) - (b.x + b.y))[0];
            
            if (tl && tr && bl && br) {
                return [tl, tr, br, bl]; // Clockwise from top-left
            }
            
            return null;
        }

        function drawDetectionOverlay(contour) {
            overlayCtx.clearRect(0, 0, scanOverlay.width, scanOverlay.height);
            
            if (contour) {
                overlayCtx.strokeStyle = '#00ff00';
                overlayCtx.beginPath();
                overlayCtx.moveTo(contour[0].x, contour[0].y);
                for (let i = 1; i < contour.length; i++) {
                    overlayCtx.lineTo(contour[i].x, contour[i].y);
                }
                overlayCtx.closePath();
                overlayCtx.stroke();
                
                // Draw corner points
                contour.forEach(point => {
                    overlayCtx.fillStyle = '#00ff00';
                    overlayCtx.beginPath();
                    overlayCtx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
                    overlayCtx.fill();
                });
            }
        }

        function isDocumentWellPositioned(contour) {
            const centerX = processingCanvas.width / 2;
            const centerY = processingCanvas.height / 2;
            
            const docCenterX = contour.reduce((sum, p) => sum + p.x, 0) / 4;
            const docCenterY = contour.reduce((sum, p) => sum + p.y, 0) / 4;
            
            return Math.abs(docCenterX - centerX) < 100 && Math.abs(docCenterY - centerY) < 100;
        }

        function performScan(contour) {
            if (scanInterval) return; // Prevent multiple scans
            
            status.textContent = 'CAPTURING DOCUMENT...';
            scanInterval = setTimeout(() => {
                processDocument(contour);
                scanInterval = null;
            }, 500);
        }

        function processDocument(contour) {
            ctx.drawImage(video, 0, 0);
            
            // Apply perspective correction and enhancement
            const scannedImage = applyPerspectiveCorrection(contour);
            applyImageEnhancement(scannedImage);
            
            resultImage.src = outputCanvas.toDataURL('image/jpeg', 0.95);
            resultContainer.style.display = 'block';
            
            status.textContent = 'DOCUMENT SCANNED - READY FOR PDF';
        }

        function applyPerspectiveCorrection(contour) {
            const srcPoints = contour;
            const dstPoints = [
                {x: 0, y: 0},
                {x: outputCanvas.width, y: 0},
                {x: outputCanvas.width, y: outputCanvas.height},
                {x: 0, y: outputCanvas.height}
            ];
            
            // Simple affine transform (simplified)
            outputCtx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            outputCtx.drawImage(processingCanvas, 0, 0);
            
            return outputCanvas;
        }

        function applyImageEnhancement(canvas) {
            const imageData = outputCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Simple contrast enhancement
            for (let i = 0; i < data.length; i += 4) {
                // Increase contrast
                data[i] = Math.min(255, data[i] * 1.2);     // R
                data[i + 1] = Math.min(255, data[i + 1] * 1.2); // G
                data[i + 2] = Math.min(255, data[i + 2] * 1.2); // B
            }
            
            outputCtx.putImageData(imageData, 0, 0);
        }

        // Event handlers
        document.getElementById('toggleCamera').addEventListener('click', async () => {
            isFrontCamera = !isFrontCamera;
            status.textContent = 'SWITCHING CAMERA...';
            await startCamera();
            status.textContent = 'CAMERA SWITCHED - READY TO SCAN';
        });

        document.getElementById('flashToggle').addEventListener('click', () => {
            flashOn = !flashOn;
            this.textContent = `FLASH: ${flashOn ? 'ON' : 'OFF'}`;
            // Flash simulation (actual flash requires specific device support)
        });

        document.getElementById('captureBtn').addEventListener('click', () => {
            ctx.drawImage(video, 0, 0);
            const contour = findDocumentContour(detectEdgesAdvanced(
                ctx.getImageData(0, 0, processingCanvas.width, processingCanvas.height)
            ));
            if (contour) {
                performScan(contour);
            } else {
                status.textContent = 'NO DOCUMENT DETECTED - TRY AGAIN';
            }
        });

        document.getElementById('autoScanBtn').addEventListener('click', function() {
            isAutoScan = !isAutoScan;
            this.style.background = isAutoScan ? '#004400' : '#440000';
            this.textContent = `AUTO-SCAN: ${isAutoScan ? 'ON' : 'OFF'}`;
            status.textContent = isAutoScan ? 'AUTO-SCAN ENABLED' : 'AUTO-SCAN DISABLED';
        });

        document.getElementById('retakeBtn').addEventListener('click', () => {
            resultContainer.style.display = 'none';
            status.textContent = 'READY TO SCAN - POINT AT DOCUMENT';
        });

        document.getElementById('savePdfBtn').addEventListener('click', () => {
            status.textContent = 'GENERATING PDF...';
            
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF();
            
            const imgData = resultImage.src;
            const imgProps = pdf.getImageProperties(imgData);
            const pdfWidth = pdf.internal.pageSize.getWidth();
            const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
            
            pdf.addImage(imgData, 'JPEG', 0, 0, pdfWidth, pdfHeight);
            pdf.save(`nekoscan-${Date.now()}.pdf`);
            
            status.textContent = 'PDF SAVED SUCCESSFULLY';
        });

        document.getElementById('enhanceBtn').addEventListener('click', () => {
            status.textContent = 'ENHANCING IMAGE QUALITY...';
            applyImageEnhancement(outputCanvas);
            resultImage.src = outputCanvas.toDataURL('image/jpeg', 0.95);
            status.textContent = 'IMAGE ENHANCED';
        });

        document.getElementById('shareBtn').addEventListener('click', async () => {
            if (navigator.share) {
                try {
                    const response = await fetch(resultImage.src);
                    const blob = await response.blob();
                    const file = new File([blob], 'document-scan.jpg', { type: 'image/jpeg' });
                    
                    await navigator.share({
                        files: [file],
                        title: 'Document Scan',
                        text: 'Scanned with NekoScan Pro'
                    });
                } catch (err) {
                    status.textContent = 'SHARE CANCELLED';
                }
            } else {
                status.textContent = 'SHARE NOT SUPPORTED ON THIS DEVICE';
            }
        });

        // Initialize scanner when page loads
        window.addEventListener('load', initializeScanner);

        // Clean up on page unload
        window.addEventListener('beforeunload', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>